// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v3.21.12
// source: config.proto
package proto_nsjail

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Mode int32

const (
	Mode_LISTEN Mode = 0 // Listening on a TCP port
	Mode_ONCE   Mode = 1 // Running the command once only
	Mode_RERUN  Mode = 2 // Re-executing the command (forever)
	Mode_EXECVE Mode = 3 // Executing command w/o the supervisor
)

// Enum value maps for Mode.
var (
	Mode_name = map[int32]string{
		0: "LISTEN",
		1: "ONCE",
		2: "RERUN",
		3: "EXECVE",
	}
	Mode_value = map[string]int32{
		"LISTEN": 0,
		"ONCE":   1,
		"RERUN":  2,
		"EXECVE": 3,
	}
)

func (x Mode) Enum() *Mode {
	p := new(Mode)
	*p = x
	return p
}

func (x Mode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Mode) Descriptor() protoreflect.EnumDescriptor {
	return file_config_proto_enumTypes[0].Descriptor()
}

func (Mode) Type() protoreflect.EnumType {
	return &file_config_proto_enumTypes[0]
}

func (x Mode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Mode) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Mode(num)
	return nil
}

// Deprecated: Use Mode.Descriptor instead.
func (Mode) EnumDescriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{0}
}

// Should be self explanatory
type LogLevel int32

const (
	LogLevel_DEBUG   LogLevel = 0 // Equivalent to the '-v' cmd-line option
	LogLevel_INFO    LogLevel = 1 // Default level
	LogLevel_WARNING LogLevel = 2 // Equivalent to the '-q' cmd-line option
	LogLevel_ERROR   LogLevel = 3
	LogLevel_FATAL   LogLevel = 4
)

// Enum value maps for LogLevel.
var (
	LogLevel_name = map[int32]string{
		0: "DEBUG",
		1: "INFO",
		2: "WARNING",
		3: "ERROR",
		4: "FATAL",
	}
	LogLevel_value = map[string]int32{
		"DEBUG":   0,
		"INFO":    1,
		"WARNING": 2,
		"ERROR":   3,
		"FATAL":   4,
	}
)

func (x LogLevel) Enum() *LogLevel {
	p := new(LogLevel)
	*p = x
	return p
}

func (x LogLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LogLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_config_proto_enumTypes[1].Descriptor()
}

func (LogLevel) Type() protoreflect.EnumType {
	return &file_config_proto_enumTypes[1]
}

func (x LogLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *LogLevel) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = LogLevel(num)
	return nil
}

// Deprecated: Use LogLevel.Descriptor instead.
func (LogLevel) EnumDescriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{1}
}

type RLimit int32

const (
	RLimit_VALUE RLimit = 0 // Use the provided value
	RLimit_SOFT  RLimit = 1 // Use the current soft rlimit
	RLimit_HARD  RLimit = 2 // Use the current hard rlimit
	RLimit_INF   RLimit = 3 // Use RLIM64_INFINITY
)

// Enum value maps for RLimit.
var (
	RLimit_name = map[int32]string{
		0: "VALUE",
		1: "SOFT",
		2: "HARD",
		3: "INF",
	}
	RLimit_value = map[string]int32{
		"VALUE": 0,
		"SOFT":  1,
		"HARD":  2,
		"INF":   3,
	}
)

func (x RLimit) Enum() *RLimit {
	p := new(RLimit)
	*p = x
	return p
}

func (x RLimit) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RLimit) Descriptor() protoreflect.EnumDescriptor {
	return file_config_proto_enumTypes[2].Descriptor()
}

func (RLimit) Type() protoreflect.EnumType {
	return &file_config_proto_enumTypes[2]
}

func (x RLimit) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *RLimit) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = RLimit(num)
	return nil
}

// Deprecated: Use RLimit.Descriptor instead.
func (RLimit) EnumDescriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{2}
}

type IdMap struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Empty string means "current uid/gid"
	InsideId  *string `protobuf:"bytes,1,opt,name=inside_id,json=insideId,def=" json:"inside_id,omitempty"`
	OutsideId *string `protobuf:"bytes,2,opt,name=outside_id,json=outsideId,def=" json:"outside_id,omitempty"`
	// See 'man user_namespaces' for the meaning of count
	Count *uint32 `protobuf:"varint,3,opt,name=count,def=1" json:"count,omitempty"`
	// Does this map use /usr/bin/new[u|g]idmap binary?
	UseNewidmap   *bool `protobuf:"varint,4,opt,name=use_newidmap,json=useNewidmap,def=0" json:"use_newidmap,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for IdMap fields.
const (
	Default_IdMap_InsideId    = string("")
	Default_IdMap_OutsideId   = string("")
	Default_IdMap_Count       = uint32(1)
	Default_IdMap_UseNewidmap = bool(false)
)

func (x *IdMap) Reset() {
	*x = IdMap{}
	mi := &file_config_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IdMap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IdMap) ProtoMessage() {}

func (x *IdMap) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IdMap.ProtoReflect.Descriptor instead.
func (*IdMap) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{0}
}

func (x *IdMap) GetInsideId() string {
	if x != nil && x.InsideId != nil {
		return *x.InsideId
	}
	return Default_IdMap_InsideId
}

func (x *IdMap) GetOutsideId() string {
	if x != nil && x.OutsideId != nil {
		return *x.OutsideId
	}
	return Default_IdMap_OutsideId
}

func (x *IdMap) GetCount() uint32 {
	if x != nil && x.Count != nil {
		return *x.Count
	}
	return Default_IdMap_Count
}

func (x *IdMap) GetUseNewidmap() bool {
	if x != nil && x.UseNewidmap != nil {
		return *x.UseNewidmap
	}
	return Default_IdMap_UseNewidmap
}

type MountPt struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Can be skipped for filesystems like 'proc'
	Src *string `protobuf:"bytes,1,opt,name=src,def=" json:"src,omitempty"`
	// Should 'src' path be prefixed with this envar?
	PrefixSrcEnv *string `protobuf:"bytes,2,opt,name=prefix_src_env,json=prefixSrcEnv,def=" json:"prefix_src_env,omitempty"`
	// If specified, contains buffer that will be written to the dst file
	SrcContent []byte `protobuf:"bytes,3,opt,name=src_content,json=srcContent,def=" json:"src_content,omitempty"`
	// Mount point inside jail
	Dst *string `protobuf:"bytes,4,req,name=dst,def=" json:"dst,omitempty"`
	// Should 'dst' path be prefixed with this envar?
	PrefixDstEnv *string `protobuf:"bytes,5,opt,name=prefix_dst_env,json=prefixDstEnv,def=" json:"prefix_dst_env,omitempty"`
	// Can be empty for mount --bind mounts
	Fstype *string `protobuf:"bytes,6,opt,name=fstype,def=" json:"fstype,omitempty"`
	// E.g. size=5000000 for 'tmpfs'
	Options *string `protobuf:"bytes,7,opt,name=options,def=" json:"options,omitempty"`
	// Is it a 'mount --bind src dst' type of mount?
	IsBind *bool `protobuf:"varint,8,opt,name=is_bind,json=isBind,def=0" json:"is_bind,omitempty"`
	// Is it a R/W mount?
	Rw *bool `protobuf:"varint,9,opt,name=rw,def=0" json:"rw,omitempty"`
	// Is it a directory? If not specified an internal
	// heuristics will be used to determine that
	IsDir *bool `protobuf:"varint,10,opt,name=is_dir,json=isDir" json:"is_dir,omitempty"`
	// Should the sandboxing fail if we cannot mount this resource?
	Mandatory *bool `protobuf:"varint,11,opt,name=mandatory,def=1" json:"mandatory,omitempty"`
	// Is it a symlink (instead of real mount point)?
	IsSymlink *bool `protobuf:"varint,12,opt,name=is_symlink,json=isSymlink,def=0" json:"is_symlink,omitempty"`
	// Is it a nosuid mount
	Nosuid *bool `protobuf:"varint,13,opt,name=nosuid,def=0" json:"nosuid,omitempty"`
	// Is it a nodev mount
	Nodev *bool `protobuf:"varint,14,opt,name=nodev,def=0" json:"nodev,omitempty"`
	// Is it a noexec mount
	Noexec        *bool `protobuf:"varint,15,opt,name=noexec,def=0" json:"noexec,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for MountPt fields.
const (
	Default_MountPt_Src          = string("")
	Default_MountPt_PrefixSrcEnv = string("")
	Default_MountPt_Dst          = string("")
	Default_MountPt_PrefixDstEnv = string("")
	Default_MountPt_Fstype       = string("")
	Default_MountPt_Options      = string("")
	Default_MountPt_IsBind       = bool(false)
	Default_MountPt_Rw           = bool(false)
	Default_MountPt_Mandatory    = bool(true)
	Default_MountPt_IsSymlink    = bool(false)
	Default_MountPt_Nosuid       = bool(false)
	Default_MountPt_Nodev        = bool(false)
	Default_MountPt_Noexec       = bool(false)
)

// Default values for MountPt fields.
var (
	Default_MountPt_SrcContent = []byte("")
)

func (x *MountPt) Reset() {
	*x = MountPt{}
	mi := &file_config_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MountPt) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MountPt) ProtoMessage() {}

func (x *MountPt) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MountPt.ProtoReflect.Descriptor instead.
func (*MountPt) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{1}
}

func (x *MountPt) GetSrc() string {
	if x != nil && x.Src != nil {
		return *x.Src
	}
	return Default_MountPt_Src
}

func (x *MountPt) GetPrefixSrcEnv() string {
	if x != nil && x.PrefixSrcEnv != nil {
		return *x.PrefixSrcEnv
	}
	return Default_MountPt_PrefixSrcEnv
}

func (x *MountPt) GetSrcContent() []byte {
	if x != nil && x.SrcContent != nil {
		return x.SrcContent
	}
	return append([]byte(nil), Default_MountPt_SrcContent...)
}

func (x *MountPt) GetDst() string {
	if x != nil && x.Dst != nil {
		return *x.Dst
	}
	return Default_MountPt_Dst
}

func (x *MountPt) GetPrefixDstEnv() string {
	if x != nil && x.PrefixDstEnv != nil {
		return *x.PrefixDstEnv
	}
	return Default_MountPt_PrefixDstEnv
}

func (x *MountPt) GetFstype() string {
	if x != nil && x.Fstype != nil {
		return *x.Fstype
	}
	return Default_MountPt_Fstype
}

func (x *MountPt) GetOptions() string {
	if x != nil && x.Options != nil {
		return *x.Options
	}
	return Default_MountPt_Options
}

func (x *MountPt) GetIsBind() bool {
	if x != nil && x.IsBind != nil {
		return *x.IsBind
	}
	return Default_MountPt_IsBind
}

func (x *MountPt) GetRw() bool {
	if x != nil && x.Rw != nil {
		return *x.Rw
	}
	return Default_MountPt_Rw
}

func (x *MountPt) GetIsDir() bool {
	if x != nil && x.IsDir != nil {
		return *x.IsDir
	}
	return false
}

func (x *MountPt) GetMandatory() bool {
	if x != nil && x.Mandatory != nil {
		return *x.Mandatory
	}
	return Default_MountPt_Mandatory
}

func (x *MountPt) GetIsSymlink() bool {
	if x != nil && x.IsSymlink != nil {
		return *x.IsSymlink
	}
	return Default_MountPt_IsSymlink
}

func (x *MountPt) GetNosuid() bool {
	if x != nil && x.Nosuid != nil {
		return *x.Nosuid
	}
	return Default_MountPt_Nosuid
}

func (x *MountPt) GetNodev() bool {
	if x != nil && x.Nodev != nil {
		return *x.Nodev
	}
	return Default_MountPt_Nodev
}

func (x *MountPt) GetNoexec() bool {
	if x != nil && x.Noexec != nil {
		return *x.Noexec
	}
	return Default_MountPt_Noexec
}

type Exe struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Will be used both as execv's path and as argv[0]
	Path *string `protobuf:"bytes,1,req,name=path" json:"path,omitempty"`
	// This will be argv[1] and so on..
	Arg []string `protobuf:"bytes,2,rep,name=arg" json:"arg,omitempty"`
	// Override argv[0]
	Arg0 *string `protobuf:"bytes,3,opt,name=arg0" json:"arg0,omitempty"`
	// Should execveat() be used to execute a file-descriptor instead?
	ExecFd        *bool `protobuf:"varint,4,opt,name=exec_fd,json=execFd,def=0" json:"exec_fd,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for Exe fields.
const (
	Default_Exe_ExecFd = bool(false)
)

func (x *Exe) Reset() {
	*x = Exe{}
	mi := &file_config_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Exe) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Exe) ProtoMessage() {}

func (x *Exe) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Exe.ProtoReflect.Descriptor instead.
func (*Exe) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{2}
}

func (x *Exe) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *Exe) GetArg() []string {
	if x != nil {
		return x.Arg
	}
	return nil
}

func (x *Exe) GetArg0() string {
	if x != nil && x.Arg0 != nil {
		return *x.Arg0
	}
	return ""
}

func (x *Exe) GetExecFd() bool {
	if x != nil && x.ExecFd != nil {
		return *x.ExecFd
	}
	return Default_Exe_ExecFd
}

type NsJailConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional name and description for this config
	Name        *string  `protobuf:"bytes,1,opt,name=name,def=" json:"name,omitempty"`
	Description []string `protobuf:"bytes,2,rep,name=description" json:"description,omitempty"`
	// Execution mode: see 'msg Mode' description for more
	Mode *Mode `protobuf:"varint,3,opt,name=mode,enum=nsjail.Mode,def=1" json:"mode,omitempty"`
	// Hostname inside jail
	Hostname *string `protobuf:"bytes,4,opt,name=hostname,def=NSJAIL" json:"hostname,omitempty"`
	// Initial current working directory for the binary
	Cwd *string `protobuf:"bytes,5,opt,name=cwd,def=/" json:"cwd,omitempty"`
	// Defines whether to use switch_root or pivot_root
	NoPivotroot *bool `protobuf:"varint,6,opt,name=no_pivotroot,json=noPivotroot,def=0" json:"no_pivotroot,omitempty"`
	// TCP port to listen to. Valid with mode=LISTEN only
	Port *uint32 `protobuf:"varint,7,opt,name=port,def=0" json:"port,omitempty"`
	// Host to bind to for mode=LISTEN. Must be in IPv6 format
	Bindhost *string `protobuf:"bytes,8,opt,name=bindhost,def=::" json:"bindhost,omitempty"`
	// For mode=LISTEN, maximum number of connections across all IPs
	MaxConns *uint32 `protobuf:"varint,9,opt,name=max_conns,json=maxConns,def=0" json:"max_conns,omitempty"`
	// For mode=LISTEN, maximum number of connections from a single IP
	MaxConnsPerIp *uint32 `protobuf:"varint,10,opt,name=max_conns_per_ip,json=maxConnsPerIp,def=0" json:"max_conns_per_ip,omitempty"`
	// Wall-time time limit for commands
	TimeLimit *uint32 `protobuf:"varint,11,opt,name=time_limit,json=timeLimit,def=600" json:"time_limit,omitempty"`
	// Should nsjail go into background?
	Daemon *bool `protobuf:"varint,12,opt,name=daemon,def=0" json:"daemon,omitempty"`
	// Maximum number of CPUs to use: 0 - no limit
	MaxCpus *uint32 `protobuf:"varint,13,opt,name=max_cpus,json=maxCpus,def=0" json:"max_cpus,omitempty"`
	// Niceness level of the jailed process
	NiceLevel *int32 `protobuf:"varint,14,opt,name=nice_level,json=niceLevel,def=19" json:"nice_level,omitempty"`
	// FD to log to.
	LogFd *int32 `protobuf:"varint,15,opt,name=log_fd,json=logFd" json:"log_fd,omitempty"`
	// File to save logs to.
	LogFile *string `protobuf:"bytes,16,opt,name=log_file,json=logFile" json:"log_file,omitempty"`
	// Minimum log level displayed.
	// See 'msg LogLevel' description for more
	LogLevel *LogLevel `protobuf:"varint,17,opt,name=log_level,json=logLevel,enum=nsjail.LogLevel" json:"log_level,omitempty"`
	// Should the current environment variables be kept
	// when executing the binary
	KeepEnv *bool `protobuf:"varint,18,opt,name=keep_env,json=keepEnv,def=0" json:"keep_env,omitempty"`
	// EnvVars to be set before executing binaries. If the envar doesn't contain '='
	// (e.g. just the 'DISPLAY' string), the current envar value will be used
	Envar []string `protobuf:"bytes,19,rep,name=envar" json:"envar,omitempty"`
	// Should capabilities be preserved or dropped
	KeepCaps *bool `protobuf:"varint,20,opt,name=keep_caps,json=keepCaps,def=0" json:"keep_caps,omitempty"`
	// Which capabilities should be preserved if keep_caps == false.
	// Format: "CAP_SYS_PTRACE"
	Cap []string `protobuf:"bytes,21,rep,name=cap" json:"cap,omitempty"`
	// Should nsjail close FD=0,1,2 before executing the process
	Silent *bool `protobuf:"varint,22,opt,name=silent,def=0" json:"silent,omitempty"`
	// Should the child process have control over terminal?
	// Can be useful to allow /bin/sh to provide
	// job control / signals. Dangerous, can be used to put
	// characters into the controlling terminal back
	SkipSetsid *bool `protobuf:"varint,23,opt,name=skip_setsid,json=skipSetsid,def=0" json:"skip_setsid,omitempty"`
	// Redirect sdterr of the process to /dev/null instead of the socket or original TTY
	StderrToNull *bool `protobuf:"varint,24,opt,name=stderr_to_null,json=stderrToNull,def=0" json:"stderr_to_null,omitempty"`
	// Which FDs should be passed to the newly executed process
	// By default only FD=0,1,2 are passed
	PassFd []int32 `protobuf:"varint,25,rep,name=pass_fd,json=passFd" json:"pass_fd,omitempty"`
	// Setting it to true will allow to have set-uid binaries
	// inside the jail
	DisableNoNewPrivs *bool `protobuf:"varint,26,opt,name=disable_no_new_privs,json=disableNoNewPrivs,def=0" json:"disable_no_new_privs,omitempty"`
	// Set this to true to forward fatal signals to the child process instead
	// of always using SIGKILL.
	ForwardSignals *bool `protobuf:"varint,27,opt,name=forward_signals,json=forwardSignals,def=0" json:"forward_signals,omitempty"`
	// Disable rdtsc and rdtscp instructions. WARNING: To make it effective, you also need to
	// forbid `prctl(PR_SET_TSC, PR_TSC_ENABLE, ...)` in seccomp rules! (x86 and x86_64 only).
	// Dynamic binaries produced by GCC seem to rely on RDTSC, but static ones should work.
	DisableTsc *bool `protobuf:"varint,28,opt,name=disable_tsc,json=disableTsc,def=0" json:"disable_tsc,omitempty"`
	// Various rlimits, the rlimit_as/rlimit_core/... are used only if
	// rlimit_as_type/rlimit_core_type/... are set to RLimit::VALUE
	RlimitAs         *uint64 `protobuf:"varint,29,opt,name=rlimit_as,json=rlimitAs,def=4096" json:"rlimit_as,omitempty"` // In MiB
	RlimitAsType     *RLimit `protobuf:"varint,30,opt,name=rlimit_as_type,json=rlimitAsType,enum=nsjail.RLimit,def=0" json:"rlimit_as_type,omitempty"`
	RlimitCore       *uint64 `protobuf:"varint,31,opt,name=rlimit_core,json=rlimitCore,def=0" json:"rlimit_core,omitempty"` // In MiB
	RlimitCoreType   *RLimit `protobuf:"varint,32,opt,name=rlimit_core_type,json=rlimitCoreType,enum=nsjail.RLimit,def=0" json:"rlimit_core_type,omitempty"`
	RlimitCpu        *uint64 `protobuf:"varint,33,opt,name=rlimit_cpu,json=rlimitCpu,def=600" json:"rlimit_cpu,omitempty"` // In seconds
	RlimitCpuType    *RLimit `protobuf:"varint,34,opt,name=rlimit_cpu_type,json=rlimitCpuType,enum=nsjail.RLimit,def=0" json:"rlimit_cpu_type,omitempty"`
	RlimitFsize      *uint64 `protobuf:"varint,35,opt,name=rlimit_fsize,json=rlimitFsize,def=1" json:"rlimit_fsize,omitempty"` // In MiB
	RlimitFsizeType  *RLimit `protobuf:"varint,36,opt,name=rlimit_fsize_type,json=rlimitFsizeType,enum=nsjail.RLimit,def=0" json:"rlimit_fsize_type,omitempty"`
	RlimitNofile     *uint64 `protobuf:"varint,37,opt,name=rlimit_nofile,json=rlimitNofile,def=32" json:"rlimit_nofile,omitempty"`
	RlimitNofileType *RLimit `protobuf:"varint,38,opt,name=rlimit_nofile_type,json=rlimitNofileType,enum=nsjail.RLimit,def=0" json:"rlimit_nofile_type,omitempty"`
	// RLIMIT_NPROC is system-wide - tricky to use; use the soft limit value by
	// default here
	RlimitNproc     *uint64 `protobuf:"varint,39,opt,name=rlimit_nproc,json=rlimitNproc,def=1024" json:"rlimit_nproc,omitempty"`
	RlimitNprocType *RLimit `protobuf:"varint,40,opt,name=rlimit_nproc_type,json=rlimitNprocType,enum=nsjail.RLimit,def=1" json:"rlimit_nproc_type,omitempty"`
	// In MiB, use the soft limit value by default
	RlimitStack     *uint64 `protobuf:"varint,41,opt,name=rlimit_stack,json=rlimitStack,def=8" json:"rlimit_stack,omitempty"`
	RlimitStackType *RLimit `protobuf:"varint,42,opt,name=rlimit_stack_type,json=rlimitStackType,enum=nsjail.RLimit,def=1" json:"rlimit_stack_type,omitempty"`
	// In KB, use the soft limit value by default
	RlimitMemlock      *uint64 `protobuf:"varint,43,opt,name=rlimit_memlock,json=rlimitMemlock,def=64" json:"rlimit_memlock,omitempty"`
	RlimitMemlockType  *RLimit `protobuf:"varint,44,opt,name=rlimit_memlock_type,json=rlimitMemlockType,enum=nsjail.RLimit,def=1" json:"rlimit_memlock_type,omitempty"`
	RlimitRtprio       *uint64 `protobuf:"varint,45,opt,name=rlimit_rtprio,json=rlimitRtprio,def=0" json:"rlimit_rtprio,omitempty"`
	RlimitRtprioType   *RLimit `protobuf:"varint,46,opt,name=rlimit_rtprio_type,json=rlimitRtprioType,enum=nsjail.RLimit,def=1" json:"rlimit_rtprio_type,omitempty"`
	RlimitMsgqueue     *uint64 `protobuf:"varint,47,opt,name=rlimit_msgqueue,json=rlimitMsgqueue,def=1024" json:"rlimit_msgqueue,omitempty"` // In bytes
	RlimitMsgqueueType *RLimit `protobuf:"varint,48,opt,name=rlimit_msgqueue_type,json=rlimitMsgqueueType,enum=nsjail.RLimit,def=1" json:"rlimit_msgqueue_type,omitempty"`
	// Disable all rlimits, default to limits set by parent
	DisableRl *bool `protobuf:"varint,49,opt,name=disable_rl,json=disableRl,def=0" json:"disable_rl,omitempty"`
	// See 'man personality' for more
	PersonaAddrCompatLayout *bool `protobuf:"varint,50,opt,name=persona_addr_compat_layout,json=personaAddrCompatLayout,def=0" json:"persona_addr_compat_layout,omitempty"`
	PersonaMmapPageZero     *bool `protobuf:"varint,51,opt,name=persona_mmap_page_zero,json=personaMmapPageZero,def=0" json:"persona_mmap_page_zero,omitempty"`
	PersonaReadImpliesExec  *bool `protobuf:"varint,52,opt,name=persona_read_implies_exec,json=personaReadImpliesExec,def=0" json:"persona_read_implies_exec,omitempty"`
	PersonaAddrLimit_3Gb    *bool `protobuf:"varint,53,opt,name=persona_addr_limit_3gb,json=personaAddrLimit3gb,def=0" json:"persona_addr_limit_3gb,omitempty"`
	PersonaAddrNoRandomize  *bool `protobuf:"varint,54,opt,name=persona_addr_no_randomize,json=personaAddrNoRandomize,def=0" json:"persona_addr_no_randomize,omitempty"`
	// Which name-spaces should be used?
	CloneNewnet  *bool `protobuf:"varint,55,opt,name=clone_newnet,json=cloneNewnet,def=1" json:"clone_newnet,omitempty"`
	CloneNewuser *bool `protobuf:"varint,56,opt,name=clone_newuser,json=cloneNewuser,def=1" json:"clone_newuser,omitempty"`
	CloneNewns   *bool `protobuf:"varint,57,opt,name=clone_newns,json=cloneNewns,def=1" json:"clone_newns,omitempty"`
	CloneNewpid  *bool `protobuf:"varint,58,opt,name=clone_newpid,json=cloneNewpid,def=1" json:"clone_newpid,omitempty"`
	CloneNewipc  *bool `protobuf:"varint,59,opt,name=clone_newipc,json=cloneNewipc,def=1" json:"clone_newipc,omitempty"`
	CloneNewuts  *bool `protobuf:"varint,60,opt,name=clone_newuts,json=cloneNewuts,def=1" json:"clone_newuts,omitempty"`
	// Disable for kernel versions < 4.6 as it's not supported there
	CloneNewcgroup *bool `protobuf:"varint,61,opt,name=clone_newcgroup,json=cloneNewcgroup,def=1" json:"clone_newcgroup,omitempty"`
	// Supported with kernel versions >= 5.3
	CloneNewtime *bool `protobuf:"varint,62,opt,name=clone_newtime,json=cloneNewtime,def=0" json:"clone_newtime,omitempty"`
	// Mappings for UIDs and GIDs. See the description for 'msg IdMap'
	// for more
	Uidmap []*IdMap `protobuf:"bytes,63,rep,name=uidmap" json:"uidmap,omitempty"`
	Gidmap []*IdMap `protobuf:"bytes,64,rep,name=gidmap" json:"gidmap,omitempty"`
	// Should /proc be mounted (R/O)? This can also be added in the 'mount'
	// section below
	MountProc *bool `protobuf:"varint,65,opt,name=mount_proc,json=mountProc,def=0" json:"mount_proc,omitempty"`
	// Mount points inside the jail. See the description for 'msg MountPt'
	// for more
	Mount []*MountPt `protobuf:"bytes,66,rep,name=mount" json:"mount,omitempty"`
	// Kafel seccomp-bpf policy file or a string:
	// Homepage of the project: https://github.com/google/kafel
	SeccompPolicyFile *string  `protobuf:"bytes,67,opt,name=seccomp_policy_file,json=seccompPolicyFile" json:"seccomp_policy_file,omitempty"`
	SeccompString     []string `protobuf:"bytes,68,rep,name=seccomp_string,json=seccompString" json:"seccomp_string,omitempty"`
	// Setting it to true makes audit write seccomp logs to dmesg
	SeccompLog *bool `protobuf:"varint,69,opt,name=seccomp_log,json=seccompLog,def=0" json:"seccomp_log,omitempty"`
	// If > 0, maximum cumulative size of RAM used inside any jail
	CgroupMemMax *uint64 `protobuf:"varint,70,opt,name=cgroup_mem_max,json=cgroupMemMax,def=0" json:"cgroup_mem_max,omitempty"` // In bytes
	// If > 0, maximum cumulative size of RAM + swap used inside any jail
	CgroupMemMemswMax *uint64 `protobuf:"varint,71,opt,name=cgroup_mem_memsw_max,json=cgroupMemMemswMax,def=0" json:"cgroup_mem_memsw_max,omitempty"` // In bytes
	// If >= 0, maximum cumulative size of swap used inside any jail
	CgroupMemSwapMax *int64 `protobuf:"varint,72,opt,name=cgroup_mem_swap_max,json=cgroupMemSwapMax,def=-1" json:"cgroup_mem_swap_max,omitempty"` // In bytes
	// Mount point for cgroups-memory in your system
	CgroupMemMount *string `protobuf:"bytes,73,opt,name=cgroup_mem_mount,json=cgroupMemMount,def=/sys/fs/cgroup/memory" json:"cgroup_mem_mount,omitempty"`
	// Writeable directory (for the nsjail user) under cgroup_mem_mount
	CgroupMemParent *string `protobuf:"bytes,74,opt,name=cgroup_mem_parent,json=cgroupMemParent,def=NSJAIL" json:"cgroup_mem_parent,omitempty"`
	// If > 0, maximum number of PIDs (threads/processes) inside jail
	CgroupPidsMax *uint64 `protobuf:"varint,75,opt,name=cgroup_pids_max,json=cgroupPidsMax,def=0" json:"cgroup_pids_max,omitempty"`
	// Mount point for cgroups-pids in your system
	CgroupPidsMount *string `protobuf:"bytes,76,opt,name=cgroup_pids_mount,json=cgroupPidsMount,def=/sys/fs/cgroup/pids" json:"cgroup_pids_mount,omitempty"`
	// Writeable directory (for the nsjail user) under cgroup_pids_mount
	CgroupPidsParent *string `protobuf:"bytes,77,opt,name=cgroup_pids_parent,json=cgroupPidsParent,def=NSJAIL" json:"cgroup_pids_parent,omitempty"`
	// If > 0, Class identifier of network packets inside jail
	CgroupNetClsClassid *uint32 `protobuf:"varint,78,opt,name=cgroup_net_cls_classid,json=cgroupNetClsClassid,def=0" json:"cgroup_net_cls_classid,omitempty"`
	// Mount point for cgroups-net-cls in your system
	CgroupNetClsMount *string `protobuf:"bytes,79,opt,name=cgroup_net_cls_mount,json=cgroupNetClsMount,def=/sys/fs/cgroup/net_cls" json:"cgroup_net_cls_mount,omitempty"`
	// Writeable directory (for the nsjail user) under cgroup_net_mount
	CgroupNetClsParent *string `protobuf:"bytes,80,opt,name=cgroup_net_cls_parent,json=cgroupNetClsParent,def=NSJAIL" json:"cgroup_net_cls_parent,omitempty"`
	// If > 0, number of milliseconds of CPU time per second that jailed processes can use
	CgroupCpuMsPerSec *uint32 `protobuf:"varint,81,opt,name=cgroup_cpu_ms_per_sec,json=cgroupCpuMsPerSec,def=0" json:"cgroup_cpu_ms_per_sec,omitempty"`
	// Mount point for cgroups-cpu in your system
	CgroupCpuMount *string `protobuf:"bytes,82,opt,name=cgroup_cpu_mount,json=cgroupCpuMount,def=/sys/fs/cgroup/cpu" json:"cgroup_cpu_mount,omitempty"`
	// Writeable directory (for the nsjail user) under cgroup_cpu_mount
	CgroupCpuParent *string `protobuf:"bytes,83,opt,name=cgroup_cpu_parent,json=cgroupCpuParent,def=NSJAIL" json:"cgroup_cpu_parent,omitempty"`
	// Mount point for cgroup v2 in your system
	Cgroupv2Mount *string `protobuf:"bytes,84,opt,name=cgroupv2_mount,json=cgroupv2Mount,def=/sys/fs/cgroup" json:"cgroupv2_mount,omitempty"`
	// Use cgroup v2
	UseCgroupv2 *bool `protobuf:"varint,85,opt,name=use_cgroupv2,json=useCgroupv2,def=0" json:"use_cgroupv2,omitempty"`
	// Check whether cgroupv2 is available, and use it if available.
	DetectCgroupv2 *bool `protobuf:"varint,86,opt,name=detect_cgroupv2,json=detectCgroupv2,def=0" json:"detect_cgroupv2,omitempty"`
	// Should the 'lo' interface be brought up (active) inside this jail?
	IfaceNoLo *bool `protobuf:"varint,87,opt,name=iface_no_lo,json=ifaceNoLo,def=0" json:"iface_no_lo,omitempty"`
	// Put this interface inside the jail
	IfaceOwn []string `protobuf:"bytes,88,rep,name=iface_own,json=ifaceOwn" json:"iface_own,omitempty"`
	// Parameters for the cloned MACVLAN interface inside jail
	MacvlanIface *string               `protobuf:"bytes,89,opt,name=macvlan_iface,json=macvlanIface" json:"macvlan_iface,omitempty"` // Interface to be cloned, eg 'eth0'
	MacvlanVsIp  *string               `protobuf:"bytes,90,opt,name=macvlan_vs_ip,json=macvlanVsIp,def=192.168.0.2" json:"macvlan_vs_ip,omitempty"`
	MacvlanVsNm  *string               `protobuf:"bytes,91,opt,name=macvlan_vs_nm,json=macvlanVsNm,def=255.255.255.0" json:"macvlan_vs_nm,omitempty"`
	MacvlanVsGw  *string               `protobuf:"bytes,92,opt,name=macvlan_vs_gw,json=macvlanVsGw,def=192.168.0.1" json:"macvlan_vs_gw,omitempty"`
	MacvlanVsMa  *string               `protobuf:"bytes,93,opt,name=macvlan_vs_ma,json=macvlanVsMa,def=" json:"macvlan_vs_ma,omitempty"`
	MacvlanVsMo  *string               `protobuf:"bytes,94,opt,name=macvlan_vs_mo,json=macvlanVsMo,def=private" json:"macvlan_vs_mo,omitempty"`
	UserNet      *NsJailConfig_UserNet `protobuf:"bytes,95,opt,name=user_net,json=userNet" json:"user_net,omitempty"`
	// Binary path (with arguments) to be executed. If not specified here, it
	// can be specified with cmd-line as "-- /path/to/command arg1 arg2"
	ExecBin       *Exe `protobuf:"bytes,96,opt,name=exec_bin,json=execBin" json:"exec_bin,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for NsJailConfig fields.
const (
	Default_NsJailConfig_Name                    = string("")
	Default_NsJailConfig_Mode                    = Mode_ONCE
	Default_NsJailConfig_Hostname                = string("NSJAIL")
	Default_NsJailConfig_Cwd                     = string("/")
	Default_NsJailConfig_NoPivotroot             = bool(false)
	Default_NsJailConfig_Port                    = uint32(0)
	Default_NsJailConfig_Bindhost                = string("::")
	Default_NsJailConfig_MaxConns                = uint32(0)
	Default_NsJailConfig_MaxConnsPerIp           = uint32(0)
	Default_NsJailConfig_TimeLimit               = uint32(600)
	Default_NsJailConfig_Daemon                  = bool(false)
	Default_NsJailConfig_MaxCpus                 = uint32(0)
	Default_NsJailConfig_NiceLevel               = int32(19)
	Default_NsJailConfig_KeepEnv                 = bool(false)
	Default_NsJailConfig_KeepCaps                = bool(false)
	Default_NsJailConfig_Silent                  = bool(false)
	Default_NsJailConfig_SkipSetsid              = bool(false)
	Default_NsJailConfig_StderrToNull            = bool(false)
	Default_NsJailConfig_DisableNoNewPrivs       = bool(false)
	Default_NsJailConfig_ForwardSignals          = bool(false)
	Default_NsJailConfig_DisableTsc              = bool(false)
	Default_NsJailConfig_RlimitAs                = uint64(4096)
	Default_NsJailConfig_RlimitAsType            = RLimit_VALUE
	Default_NsJailConfig_RlimitCore              = uint64(0)
	Default_NsJailConfig_RlimitCoreType          = RLimit_VALUE
	Default_NsJailConfig_RlimitCpu               = uint64(600)
	Default_NsJailConfig_RlimitCpuType           = RLimit_VALUE
	Default_NsJailConfig_RlimitFsize             = uint64(1)
	Default_NsJailConfig_RlimitFsizeType         = RLimit_VALUE
	Default_NsJailConfig_RlimitNofile            = uint64(32)
	Default_NsJailConfig_RlimitNofileType        = RLimit_VALUE
	Default_NsJailConfig_RlimitNproc             = uint64(1024)
	Default_NsJailConfig_RlimitNprocType         = RLimit_SOFT
	Default_NsJailConfig_RlimitStack             = uint64(8)
	Default_NsJailConfig_RlimitStackType         = RLimit_SOFT
	Default_NsJailConfig_RlimitMemlock           = uint64(64)
	Default_NsJailConfig_RlimitMemlockType       = RLimit_SOFT
	Default_NsJailConfig_RlimitRtprio            = uint64(0)
	Default_NsJailConfig_RlimitRtprioType        = RLimit_SOFT
	Default_NsJailConfig_RlimitMsgqueue          = uint64(1024)
	Default_NsJailConfig_RlimitMsgqueueType      = RLimit_SOFT
	Default_NsJailConfig_DisableRl               = bool(false)
	Default_NsJailConfig_PersonaAddrCompatLayout = bool(false)
	Default_NsJailConfig_PersonaMmapPageZero     = bool(false)
	Default_NsJailConfig_PersonaReadImpliesExec  = bool(false)
	Default_NsJailConfig_PersonaAddrLimit_3Gb    = bool(false)
	Default_NsJailConfig_PersonaAddrNoRandomize  = bool(false)
	Default_NsJailConfig_CloneNewnet             = bool(true)
	Default_NsJailConfig_CloneNewuser            = bool(true)
	Default_NsJailConfig_CloneNewns              = bool(true)
	Default_NsJailConfig_CloneNewpid             = bool(true)
	Default_NsJailConfig_CloneNewipc             = bool(true)
	Default_NsJailConfig_CloneNewuts             = bool(true)
	Default_NsJailConfig_CloneNewcgroup          = bool(true)
	Default_NsJailConfig_CloneNewtime            = bool(false)
	Default_NsJailConfig_MountProc               = bool(false)
	Default_NsJailConfig_SeccompLog              = bool(false)
	Default_NsJailConfig_CgroupMemMax            = uint64(0)
	Default_NsJailConfig_CgroupMemMemswMax       = uint64(0)
	Default_NsJailConfig_CgroupMemSwapMax        = int64(-1)
	Default_NsJailConfig_CgroupMemMount          = string("/sys/fs/cgroup/memory")
	Default_NsJailConfig_CgroupMemParent         = string("NSJAIL")
	Default_NsJailConfig_CgroupPidsMax           = uint64(0)
	Default_NsJailConfig_CgroupPidsMount         = string("/sys/fs/cgroup/pids")
	Default_NsJailConfig_CgroupPidsParent        = string("NSJAIL")
	Default_NsJailConfig_CgroupNetClsClassid     = uint32(0)
	Default_NsJailConfig_CgroupNetClsMount       = string("/sys/fs/cgroup/net_cls")
	Default_NsJailConfig_CgroupNetClsParent      = string("NSJAIL")
	Default_NsJailConfig_CgroupCpuMsPerSec       = uint32(0)
	Default_NsJailConfig_CgroupCpuMount          = string("/sys/fs/cgroup/cpu")
	Default_NsJailConfig_CgroupCpuParent         = string("NSJAIL")
	Default_NsJailConfig_Cgroupv2Mount           = string("/sys/fs/cgroup")
	Default_NsJailConfig_UseCgroupv2             = bool(false)
	Default_NsJailConfig_DetectCgroupv2          = bool(false)
	Default_NsJailConfig_IfaceNoLo               = bool(false)
	Default_NsJailConfig_MacvlanVsIp             = string("192.168.0.2")
	Default_NsJailConfig_MacvlanVsNm             = string("255.255.255.0")
	Default_NsJailConfig_MacvlanVsGw             = string("192.168.0.1")
	Default_NsJailConfig_MacvlanVsMa             = string("")
	Default_NsJailConfig_MacvlanVsMo             = string("private")
)

func (x *NsJailConfig) Reset() {
	*x = NsJailConfig{}
	mi := &file_config_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NsJailConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NsJailConfig) ProtoMessage() {}

func (x *NsJailConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NsJailConfig.ProtoReflect.Descriptor instead.
func (*NsJailConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{3}
}

func (x *NsJailConfig) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return Default_NsJailConfig_Name
}

func (x *NsJailConfig) GetDescription() []string {
	if x != nil {
		return x.Description
	}
	return nil
}

func (x *NsJailConfig) GetMode() Mode {
	if x != nil && x.Mode != nil {
		return *x.Mode
	}
	return Default_NsJailConfig_Mode
}

func (x *NsJailConfig) GetHostname() string {
	if x != nil && x.Hostname != nil {
		return *x.Hostname
	}
	return Default_NsJailConfig_Hostname
}

func (x *NsJailConfig) GetCwd() string {
	if x != nil && x.Cwd != nil {
		return *x.Cwd
	}
	return Default_NsJailConfig_Cwd
}

func (x *NsJailConfig) GetNoPivotroot() bool {
	if x != nil && x.NoPivotroot != nil {
		return *x.NoPivotroot
	}
	return Default_NsJailConfig_NoPivotroot
}

func (x *NsJailConfig) GetPort() uint32 {
	if x != nil && x.Port != nil {
		return *x.Port
	}
	return Default_NsJailConfig_Port
}

func (x *NsJailConfig) GetBindhost() string {
	if x != nil && x.Bindhost != nil {
		return *x.Bindhost
	}
	return Default_NsJailConfig_Bindhost
}

func (x *NsJailConfig) GetMaxConns() uint32 {
	if x != nil && x.MaxConns != nil {
		return *x.MaxConns
	}
	return Default_NsJailConfig_MaxConns
}

func (x *NsJailConfig) GetMaxConnsPerIp() uint32 {
	if x != nil && x.MaxConnsPerIp != nil {
		return *x.MaxConnsPerIp
	}
	return Default_NsJailConfig_MaxConnsPerIp
}

func (x *NsJailConfig) GetTimeLimit() uint32 {
	if x != nil && x.TimeLimit != nil {
		return *x.TimeLimit
	}
	return Default_NsJailConfig_TimeLimit
}

func (x *NsJailConfig) GetDaemon() bool {
	if x != nil && x.Daemon != nil {
		return *x.Daemon
	}
	return Default_NsJailConfig_Daemon
}

func (x *NsJailConfig) GetMaxCpus() uint32 {
	if x != nil && x.MaxCpus != nil {
		return *x.MaxCpus
	}
	return Default_NsJailConfig_MaxCpus
}

func (x *NsJailConfig) GetNiceLevel() int32 {
	if x != nil && x.NiceLevel != nil {
		return *x.NiceLevel
	}
	return Default_NsJailConfig_NiceLevel
}

func (x *NsJailConfig) GetLogFd() int32 {
	if x != nil && x.LogFd != nil {
		return *x.LogFd
	}
	return 0
}

func (x *NsJailConfig) GetLogFile() string {
	if x != nil && x.LogFile != nil {
		return *x.LogFile
	}
	return ""
}

func (x *NsJailConfig) GetLogLevel() LogLevel {
	if x != nil && x.LogLevel != nil {
		return *x.LogLevel
	}
	return LogLevel_DEBUG
}

func (x *NsJailConfig) GetKeepEnv() bool {
	if x != nil && x.KeepEnv != nil {
		return *x.KeepEnv
	}
	return Default_NsJailConfig_KeepEnv
}

func (x *NsJailConfig) GetEnvar() []string {
	if x != nil {
		return x.Envar
	}
	return nil
}

func (x *NsJailConfig) GetKeepCaps() bool {
	if x != nil && x.KeepCaps != nil {
		return *x.KeepCaps
	}
	return Default_NsJailConfig_KeepCaps
}

func (x *NsJailConfig) GetCap() []string {
	if x != nil {
		return x.Cap
	}
	return nil
}

func (x *NsJailConfig) GetSilent() bool {
	if x != nil && x.Silent != nil {
		return *x.Silent
	}
	return Default_NsJailConfig_Silent
}

func (x *NsJailConfig) GetSkipSetsid() bool {
	if x != nil && x.SkipSetsid != nil {
		return *x.SkipSetsid
	}
	return Default_NsJailConfig_SkipSetsid
}

func (x *NsJailConfig) GetStderrToNull() bool {
	if x != nil && x.StderrToNull != nil {
		return *x.StderrToNull
	}
	return Default_NsJailConfig_StderrToNull
}

func (x *NsJailConfig) GetPassFd() []int32 {
	if x != nil {
		return x.PassFd
	}
	return nil
}

func (x *NsJailConfig) GetDisableNoNewPrivs() bool {
	if x != nil && x.DisableNoNewPrivs != nil {
		return *x.DisableNoNewPrivs
	}
	return Default_NsJailConfig_DisableNoNewPrivs
}

func (x *NsJailConfig) GetForwardSignals() bool {
	if x != nil && x.ForwardSignals != nil {
		return *x.ForwardSignals
	}
	return Default_NsJailConfig_ForwardSignals
}

func (x *NsJailConfig) GetDisableTsc() bool {
	if x != nil && x.DisableTsc != nil {
		return *x.DisableTsc
	}
	return Default_NsJailConfig_DisableTsc
}

func (x *NsJailConfig) GetRlimitAs() uint64 {
	if x != nil && x.RlimitAs != nil {
		return *x.RlimitAs
	}
	return Default_NsJailConfig_RlimitAs
}

func (x *NsJailConfig) GetRlimitAsType() RLimit {
	if x != nil && x.RlimitAsType != nil {
		return *x.RlimitAsType
	}
	return Default_NsJailConfig_RlimitAsType
}

func (x *NsJailConfig) GetRlimitCore() uint64 {
	if x != nil && x.RlimitCore != nil {
		return *x.RlimitCore
	}
	return Default_NsJailConfig_RlimitCore
}

func (x *NsJailConfig) GetRlimitCoreType() RLimit {
	if x != nil && x.RlimitCoreType != nil {
		return *x.RlimitCoreType
	}
	return Default_NsJailConfig_RlimitCoreType
}

func (x *NsJailConfig) GetRlimitCpu() uint64 {
	if x != nil && x.RlimitCpu != nil {
		return *x.RlimitCpu
	}
	return Default_NsJailConfig_RlimitCpu
}

func (x *NsJailConfig) GetRlimitCpuType() RLimit {
	if x != nil && x.RlimitCpuType != nil {
		return *x.RlimitCpuType
	}
	return Default_NsJailConfig_RlimitCpuType
}

func (x *NsJailConfig) GetRlimitFsize() uint64 {
	if x != nil && x.RlimitFsize != nil {
		return *x.RlimitFsize
	}
	return Default_NsJailConfig_RlimitFsize
}

func (x *NsJailConfig) GetRlimitFsizeType() RLimit {
	if x != nil && x.RlimitFsizeType != nil {
		return *x.RlimitFsizeType
	}
	return Default_NsJailConfig_RlimitFsizeType
}

func (x *NsJailConfig) GetRlimitNofile() uint64 {
	if x != nil && x.RlimitNofile != nil {
		return *x.RlimitNofile
	}
	return Default_NsJailConfig_RlimitNofile
}

func (x *NsJailConfig) GetRlimitNofileType() RLimit {
	if x != nil && x.RlimitNofileType != nil {
		return *x.RlimitNofileType
	}
	return Default_NsJailConfig_RlimitNofileType
}

func (x *NsJailConfig) GetRlimitNproc() uint64 {
	if x != nil && x.RlimitNproc != nil {
		return *x.RlimitNproc
	}
	return Default_NsJailConfig_RlimitNproc
}

func (x *NsJailConfig) GetRlimitNprocType() RLimit {
	if x != nil && x.RlimitNprocType != nil {
		return *x.RlimitNprocType
	}
	return Default_NsJailConfig_RlimitNprocType
}

func (x *NsJailConfig) GetRlimitStack() uint64 {
	if x != nil && x.RlimitStack != nil {
		return *x.RlimitStack
	}
	return Default_NsJailConfig_RlimitStack
}

func (x *NsJailConfig) GetRlimitStackType() RLimit {
	if x != nil && x.RlimitStackType != nil {
		return *x.RlimitStackType
	}
	return Default_NsJailConfig_RlimitStackType
}

func (x *NsJailConfig) GetRlimitMemlock() uint64 {
	if x != nil && x.RlimitMemlock != nil {
		return *x.RlimitMemlock
	}
	return Default_NsJailConfig_RlimitMemlock
}

func (x *NsJailConfig) GetRlimitMemlockType() RLimit {
	if x != nil && x.RlimitMemlockType != nil {
		return *x.RlimitMemlockType
	}
	return Default_NsJailConfig_RlimitMemlockType
}

func (x *NsJailConfig) GetRlimitRtprio() uint64 {
	if x != nil && x.RlimitRtprio != nil {
		return *x.RlimitRtprio
	}
	return Default_NsJailConfig_RlimitRtprio
}

func (x *NsJailConfig) GetRlimitRtprioType() RLimit {
	if x != nil && x.RlimitRtprioType != nil {
		return *x.RlimitRtprioType
	}
	return Default_NsJailConfig_RlimitRtprioType
}

func (x *NsJailConfig) GetRlimitMsgqueue() uint64 {
	if x != nil && x.RlimitMsgqueue != nil {
		return *x.RlimitMsgqueue
	}
	return Default_NsJailConfig_RlimitMsgqueue
}

func (x *NsJailConfig) GetRlimitMsgqueueType() RLimit {
	if x != nil && x.RlimitMsgqueueType != nil {
		return *x.RlimitMsgqueueType
	}
	return Default_NsJailConfig_RlimitMsgqueueType
}

func (x *NsJailConfig) GetDisableRl() bool {
	if x != nil && x.DisableRl != nil {
		return *x.DisableRl
	}
	return Default_NsJailConfig_DisableRl
}

func (x *NsJailConfig) GetPersonaAddrCompatLayout() bool {
	if x != nil && x.PersonaAddrCompatLayout != nil {
		return *x.PersonaAddrCompatLayout
	}
	return Default_NsJailConfig_PersonaAddrCompatLayout
}

func (x *NsJailConfig) GetPersonaMmapPageZero() bool {
	if x != nil && x.PersonaMmapPageZero != nil {
		return *x.PersonaMmapPageZero
	}
	return Default_NsJailConfig_PersonaMmapPageZero
}

func (x *NsJailConfig) GetPersonaReadImpliesExec() bool {
	if x != nil && x.PersonaReadImpliesExec != nil {
		return *x.PersonaReadImpliesExec
	}
	return Default_NsJailConfig_PersonaReadImpliesExec
}

func (x *NsJailConfig) GetPersonaAddrLimit_3Gb() bool {
	if x != nil && x.PersonaAddrLimit_3Gb != nil {
		return *x.PersonaAddrLimit_3Gb
	}
	return Default_NsJailConfig_PersonaAddrLimit_3Gb
}

func (x *NsJailConfig) GetPersonaAddrNoRandomize() bool {
	if x != nil && x.PersonaAddrNoRandomize != nil {
		return *x.PersonaAddrNoRandomize
	}
	return Default_NsJailConfig_PersonaAddrNoRandomize
}

func (x *NsJailConfig) GetCloneNewnet() bool {
	if x != nil && x.CloneNewnet != nil {
		return *x.CloneNewnet
	}
	return Default_NsJailConfig_CloneNewnet
}

func (x *NsJailConfig) GetCloneNewuser() bool {
	if x != nil && x.CloneNewuser != nil {
		return *x.CloneNewuser
	}
	return Default_NsJailConfig_CloneNewuser
}

func (x *NsJailConfig) GetCloneNewns() bool {
	if x != nil && x.CloneNewns != nil {
		return *x.CloneNewns
	}
	return Default_NsJailConfig_CloneNewns
}

func (x *NsJailConfig) GetCloneNewpid() bool {
	if x != nil && x.CloneNewpid != nil {
		return *x.CloneNewpid
	}
	return Default_NsJailConfig_CloneNewpid
}

func (x *NsJailConfig) GetCloneNewipc() bool {
	if x != nil && x.CloneNewipc != nil {
		return *x.CloneNewipc
	}
	return Default_NsJailConfig_CloneNewipc
}

func (x *NsJailConfig) GetCloneNewuts() bool {
	if x != nil && x.CloneNewuts != nil {
		return *x.CloneNewuts
	}
	return Default_NsJailConfig_CloneNewuts
}

func (x *NsJailConfig) GetCloneNewcgroup() bool {
	if x != nil && x.CloneNewcgroup != nil {
		return *x.CloneNewcgroup
	}
	return Default_NsJailConfig_CloneNewcgroup
}

func (x *NsJailConfig) GetCloneNewtime() bool {
	if x != nil && x.CloneNewtime != nil {
		return *x.CloneNewtime
	}
	return Default_NsJailConfig_CloneNewtime
}

func (x *NsJailConfig) GetUidmap() []*IdMap {
	if x != nil {
		return x.Uidmap
	}
	return nil
}

func (x *NsJailConfig) GetGidmap() []*IdMap {
	if x != nil {
		return x.Gidmap
	}
	return nil
}

func (x *NsJailConfig) GetMountProc() bool {
	if x != nil && x.MountProc != nil {
		return *x.MountProc
	}
	return Default_NsJailConfig_MountProc
}

func (x *NsJailConfig) GetMount() []*MountPt {
	if x != nil {
		return x.Mount
	}
	return nil
}

func (x *NsJailConfig) GetSeccompPolicyFile() string {
	if x != nil && x.SeccompPolicyFile != nil {
		return *x.SeccompPolicyFile
	}
	return ""
}

func (x *NsJailConfig) GetSeccompString() []string {
	if x != nil {
		return x.SeccompString
	}
	return nil
}

func (x *NsJailConfig) GetSeccompLog() bool {
	if x != nil && x.SeccompLog != nil {
		return *x.SeccompLog
	}
	return Default_NsJailConfig_SeccompLog
}

func (x *NsJailConfig) GetCgroupMemMax() uint64 {
	if x != nil && x.CgroupMemMax != nil {
		return *x.CgroupMemMax
	}
	return Default_NsJailConfig_CgroupMemMax
}

func (x *NsJailConfig) GetCgroupMemMemswMax() uint64 {
	if x != nil && x.CgroupMemMemswMax != nil {
		return *x.CgroupMemMemswMax
	}
	return Default_NsJailConfig_CgroupMemMemswMax
}

func (x *NsJailConfig) GetCgroupMemSwapMax() int64 {
	if x != nil && x.CgroupMemSwapMax != nil {
		return *x.CgroupMemSwapMax
	}
	return Default_NsJailConfig_CgroupMemSwapMax
}

func (x *NsJailConfig) GetCgroupMemMount() string {
	if x != nil && x.CgroupMemMount != nil {
		return *x.CgroupMemMount
	}
	return Default_NsJailConfig_CgroupMemMount
}

func (x *NsJailConfig) GetCgroupMemParent() string {
	if x != nil && x.CgroupMemParent != nil {
		return *x.CgroupMemParent
	}
	return Default_NsJailConfig_CgroupMemParent
}

func (x *NsJailConfig) GetCgroupPidsMax() uint64 {
	if x != nil && x.CgroupPidsMax != nil {
		return *x.CgroupPidsMax
	}
	return Default_NsJailConfig_CgroupPidsMax
}

func (x *NsJailConfig) GetCgroupPidsMount() string {
	if x != nil && x.CgroupPidsMount != nil {
		return *x.CgroupPidsMount
	}
	return Default_NsJailConfig_CgroupPidsMount
}

func (x *NsJailConfig) GetCgroupPidsParent() string {
	if x != nil && x.CgroupPidsParent != nil {
		return *x.CgroupPidsParent
	}
	return Default_NsJailConfig_CgroupPidsParent
}

func (x *NsJailConfig) GetCgroupNetClsClassid() uint32 {
	if x != nil && x.CgroupNetClsClassid != nil {
		return *x.CgroupNetClsClassid
	}
	return Default_NsJailConfig_CgroupNetClsClassid
}

func (x *NsJailConfig) GetCgroupNetClsMount() string {
	if x != nil && x.CgroupNetClsMount != nil {
		return *x.CgroupNetClsMount
	}
	return Default_NsJailConfig_CgroupNetClsMount
}

func (x *NsJailConfig) GetCgroupNetClsParent() string {
	if x != nil && x.CgroupNetClsParent != nil {
		return *x.CgroupNetClsParent
	}
	return Default_NsJailConfig_CgroupNetClsParent
}

func (x *NsJailConfig) GetCgroupCpuMsPerSec() uint32 {
	if x != nil && x.CgroupCpuMsPerSec != nil {
		return *x.CgroupCpuMsPerSec
	}
	return Default_NsJailConfig_CgroupCpuMsPerSec
}

func (x *NsJailConfig) GetCgroupCpuMount() string {
	if x != nil && x.CgroupCpuMount != nil {
		return *x.CgroupCpuMount
	}
	return Default_NsJailConfig_CgroupCpuMount
}

func (x *NsJailConfig) GetCgroupCpuParent() string {
	if x != nil && x.CgroupCpuParent != nil {
		return *x.CgroupCpuParent
	}
	return Default_NsJailConfig_CgroupCpuParent
}

func (x *NsJailConfig) GetCgroupv2Mount() string {
	if x != nil && x.Cgroupv2Mount != nil {
		return *x.Cgroupv2Mount
	}
	return Default_NsJailConfig_Cgroupv2Mount
}

func (x *NsJailConfig) GetUseCgroupv2() bool {
	if x != nil && x.UseCgroupv2 != nil {
		return *x.UseCgroupv2
	}
	return Default_NsJailConfig_UseCgroupv2
}

func (x *NsJailConfig) GetDetectCgroupv2() bool {
	if x != nil && x.DetectCgroupv2 != nil {
		return *x.DetectCgroupv2
	}
	return Default_NsJailConfig_DetectCgroupv2
}

func (x *NsJailConfig) GetIfaceNoLo() bool {
	if x != nil && x.IfaceNoLo != nil {
		return *x.IfaceNoLo
	}
	return Default_NsJailConfig_IfaceNoLo
}

func (x *NsJailConfig) GetIfaceOwn() []string {
	if x != nil {
		return x.IfaceOwn
	}
	return nil
}

func (x *NsJailConfig) GetMacvlanIface() string {
	if x != nil && x.MacvlanIface != nil {
		return *x.MacvlanIface
	}
	return ""
}

func (x *NsJailConfig) GetMacvlanVsIp() string {
	if x != nil && x.MacvlanVsIp != nil {
		return *x.MacvlanVsIp
	}
	return Default_NsJailConfig_MacvlanVsIp
}

func (x *NsJailConfig) GetMacvlanVsNm() string {
	if x != nil && x.MacvlanVsNm != nil {
		return *x.MacvlanVsNm
	}
	return Default_NsJailConfig_MacvlanVsNm
}

func (x *NsJailConfig) GetMacvlanVsGw() string {
	if x != nil && x.MacvlanVsGw != nil {
		return *x.MacvlanVsGw
	}
	return Default_NsJailConfig_MacvlanVsGw
}

func (x *NsJailConfig) GetMacvlanVsMa() string {
	if x != nil && x.MacvlanVsMa != nil {
		return *x.MacvlanVsMa
	}
	return Default_NsJailConfig_MacvlanVsMa
}

func (x *NsJailConfig) GetMacvlanVsMo() string {
	if x != nil && x.MacvlanVsMo != nil {
		return *x.MacvlanVsMo
	}
	return Default_NsJailConfig_MacvlanVsMo
}

func (x *NsJailConfig) GetUserNet() *NsJailConfig_UserNet {
	if x != nil {
		return x.UserNet
	}
	return nil
}

func (x *NsJailConfig) GetExecBin() *Exe {
	if x != nil {
		return x.ExecBin
	}
	return nil
}

type NsJailConfig_UserNet struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Enable        *bool                  `protobuf:"varint,1,opt,name=enable,def=0" json:"enable,omitempty"`
	Ip            *string                `protobuf:"bytes,2,opt,name=ip,def=10.255.255.2" json:"ip,omitempty"`
	Mask          *string                `protobuf:"bytes,3,opt,name=mask,def=255.255.255.0" json:"mask,omitempty"`
	Gw            *string                `protobuf:"bytes,4,opt,name=gw,def=10.255.255.1" json:"gw,omitempty"`
	Ip6           *string                `protobuf:"bytes,5,opt,name=ip6,def=fc00::2" json:"ip6,omitempty"`
	Mask6         *string                `protobuf:"bytes,6,opt,name=mask6,def=64" json:"mask6,omitempty"`
	Gw6           *string                `protobuf:"bytes,7,opt,name=gw6,def=fc00::1" json:"gw6,omitempty"`
	NsIface       *string                `protobuf:"bytes,8,opt,name=ns_iface,json=nsIface,def=eth0" json:"ns_iface,omitempty"`
	TcpPorts      *string                `protobuf:"bytes,9,opt,name=tcp_ports,json=tcpPorts,def=none" json:"tcp_ports,omitempty"`
	UdpPorts      *string                `protobuf:"bytes,10,opt,name=udp_ports,json=udpPorts,def=none" json:"udp_ports,omitempty"`
	EnableIp4Dhcp *bool                  `protobuf:"varint,11,opt,name=enable_ip4_dhcp,json=enableIp4Dhcp,def=0" json:"enable_ip4_dhcp,omitempty"`
	EnableDns     *bool                  `protobuf:"varint,12,opt,name=enable_dns,json=enableDns,def=0" json:"enable_dns,omitempty"`
	DnsForward    *string                `protobuf:"bytes,13,opt,name=dns_forward,json=dnsForward,def=" json:"dns_forward,omitempty"`
	EnableTcp     *bool                  `protobuf:"varint,14,opt,name=enable_tcp,json=enableTcp,def=1" json:"enable_tcp,omitempty"`
	EnableUdp     *bool                  `protobuf:"varint,15,opt,name=enable_udp,json=enableUdp,def=1" json:"enable_udp,omitempty"`
	EnableIcmp    *bool                  `protobuf:"varint,16,opt,name=enable_icmp,json=enableIcmp,def=1" json:"enable_icmp,omitempty"`
	NoMapGw       *bool                  `protobuf:"varint,17,opt,name=no_map_gw,json=noMapGw,def=0" json:"no_map_gw,omitempty"`
	EnableIp6Dhcp *bool                  `protobuf:"varint,18,opt,name=enable_ip6_dhcp,json=enableIp6Dhcp,def=0" json:"enable_ip6_dhcp,omitempty"`
	EnableIp6Ra   *bool                  `protobuf:"varint,19,opt,name=enable_ip6_ra,json=enableIp6Ra,def=0" json:"enable_ip6_ra,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for NsJailConfig_UserNet fields.
const (
	Default_NsJailConfig_UserNet_Enable        = bool(false)
	Default_NsJailConfig_UserNet_Ip            = string("10.255.255.2")
	Default_NsJailConfig_UserNet_Mask          = string("255.255.255.0")
	Default_NsJailConfig_UserNet_Gw            = string("10.255.255.1")
	Default_NsJailConfig_UserNet_Ip6           = string("fc00::2")
	Default_NsJailConfig_UserNet_Mask6         = string("64")
	Default_NsJailConfig_UserNet_Gw6           = string("fc00::1")
	Default_NsJailConfig_UserNet_NsIface       = string("eth0")
	Default_NsJailConfig_UserNet_TcpPorts      = string("none")
	Default_NsJailConfig_UserNet_UdpPorts      = string("none")
	Default_NsJailConfig_UserNet_EnableIp4Dhcp = bool(false)
	Default_NsJailConfig_UserNet_EnableDns     = bool(false)
	Default_NsJailConfig_UserNet_DnsForward    = string("")
	Default_NsJailConfig_UserNet_EnableTcp     = bool(true)
	Default_NsJailConfig_UserNet_EnableUdp     = bool(true)
	Default_NsJailConfig_UserNet_EnableIcmp    = bool(true)
	Default_NsJailConfig_UserNet_NoMapGw       = bool(false)
	Default_NsJailConfig_UserNet_EnableIp6Dhcp = bool(false)
	Default_NsJailConfig_UserNet_EnableIp6Ra   = bool(false)
)

func (x *NsJailConfig_UserNet) Reset() {
	*x = NsJailConfig_UserNet{}
	mi := &file_config_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NsJailConfig_UserNet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NsJailConfig_UserNet) ProtoMessage() {}

func (x *NsJailConfig_UserNet) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NsJailConfig_UserNet.ProtoReflect.Descriptor instead.
func (*NsJailConfig_UserNet) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{3, 0}
}

func (x *NsJailConfig_UserNet) GetEnable() bool {
	if x != nil && x.Enable != nil {
		return *x.Enable
	}
	return Default_NsJailConfig_UserNet_Enable
}

func (x *NsJailConfig_UserNet) GetIp() string {
	if x != nil && x.Ip != nil {
		return *x.Ip
	}
	return Default_NsJailConfig_UserNet_Ip
}

func (x *NsJailConfig_UserNet) GetMask() string {
	if x != nil && x.Mask != nil {
		return *x.Mask
	}
	return Default_NsJailConfig_UserNet_Mask
}

func (x *NsJailConfig_UserNet) GetGw() string {
	if x != nil && x.Gw != nil {
		return *x.Gw
	}
	return Default_NsJailConfig_UserNet_Gw
}

func (x *NsJailConfig_UserNet) GetIp6() string {
	if x != nil && x.Ip6 != nil {
		return *x.Ip6
	}
	return Default_NsJailConfig_UserNet_Ip6
}

func (x *NsJailConfig_UserNet) GetMask6() string {
	if x != nil && x.Mask6 != nil {
		return *x.Mask6
	}
	return Default_NsJailConfig_UserNet_Mask6
}

func (x *NsJailConfig_UserNet) GetGw6() string {
	if x != nil && x.Gw6 != nil {
		return *x.Gw6
	}
	return Default_NsJailConfig_UserNet_Gw6
}

func (x *NsJailConfig_UserNet) GetNsIface() string {
	if x != nil && x.NsIface != nil {
		return *x.NsIface
	}
	return Default_NsJailConfig_UserNet_NsIface
}

func (x *NsJailConfig_UserNet) GetTcpPorts() string {
	if x != nil && x.TcpPorts != nil {
		return *x.TcpPorts
	}
	return Default_NsJailConfig_UserNet_TcpPorts
}

func (x *NsJailConfig_UserNet) GetUdpPorts() string {
	if x != nil && x.UdpPorts != nil {
		return *x.UdpPorts
	}
	return Default_NsJailConfig_UserNet_UdpPorts
}

func (x *NsJailConfig_UserNet) GetEnableIp4Dhcp() bool {
	if x != nil && x.EnableIp4Dhcp != nil {
		return *x.EnableIp4Dhcp
	}
	return Default_NsJailConfig_UserNet_EnableIp4Dhcp
}

func (x *NsJailConfig_UserNet) GetEnableDns() bool {
	if x != nil && x.EnableDns != nil {
		return *x.EnableDns
	}
	return Default_NsJailConfig_UserNet_EnableDns
}

func (x *NsJailConfig_UserNet) GetDnsForward() string {
	if x != nil && x.DnsForward != nil {
		return *x.DnsForward
	}
	return Default_NsJailConfig_UserNet_DnsForward
}

func (x *NsJailConfig_UserNet) GetEnableTcp() bool {
	if x != nil && x.EnableTcp != nil {
		return *x.EnableTcp
	}
	return Default_NsJailConfig_UserNet_EnableTcp
}

func (x *NsJailConfig_UserNet) GetEnableUdp() bool {
	if x != nil && x.EnableUdp != nil {
		return *x.EnableUdp
	}
	return Default_NsJailConfig_UserNet_EnableUdp
}

func (x *NsJailConfig_UserNet) GetEnableIcmp() bool {
	if x != nil && x.EnableIcmp != nil {
		return *x.EnableIcmp
	}
	return Default_NsJailConfig_UserNet_EnableIcmp
}

func (x *NsJailConfig_UserNet) GetNoMapGw() bool {
	if x != nil && x.NoMapGw != nil {
		return *x.NoMapGw
	}
	return Default_NsJailConfig_UserNet_NoMapGw
}

func (x *NsJailConfig_UserNet) GetEnableIp6Dhcp() bool {
	if x != nil && x.EnableIp6Dhcp != nil {
		return *x.EnableIp6Dhcp
	}
	return Default_NsJailConfig_UserNet_EnableIp6Dhcp
}

func (x *NsJailConfig_UserNet) GetEnableIp6Ra() bool {
	if x != nil && x.EnableIp6Ra != nil {
		return *x.EnableIp6Ra
	}
	return Default_NsJailConfig_UserNet_EnableIp6Ra
}

var File_config_proto protoreflect.FileDescriptor

const file_config_proto_rawDesc = "" +
	"\n" +
	"\fconfig.proto\x12\x06nsjail\"\x8a\x01\n" +
	"\x05IdMap\x12\x1d\n" +
	"\tinside_id\x18\x01 \x01(\t:\x00R\binsideId\x12\x1f\n" +
	"\n" +
	"outside_id\x18\x02 \x01(\t:\x00R\toutsideId\x12\x17\n" +
	"\x05count\x18\x03 \x01(\r:\x011R\x05count\x12(\n" +
	"\fuse_newidmap\x18\x04 \x01(\b:\x05falseR\vuseNewidmap\"\xcd\x03\n" +
	"\aMountPt\x12\x12\n" +
	"\x03src\x18\x01 \x01(\t:\x00R\x03src\x12&\n" +
	"\x0eprefix_src_env\x18\x02 \x01(\t:\x00R\fprefixSrcEnv\x12!\n" +
	"\vsrc_content\x18\x03 \x01(\f:\x00R\n" +
	"srcContent\x12\x12\n" +
	"\x03dst\x18\x04 \x02(\t:\x00R\x03dst\x12&\n" +
	"\x0eprefix_dst_env\x18\x05 \x01(\t:\x00R\fprefixDstEnv\x12\x18\n" +
	"\x06fstype\x18\x06 \x01(\t:\x00R\x06fstype\x12\x1a\n" +
	"\aoptions\x18\a \x01(\t:\x00R\aoptions\x12\x1e\n" +
	"\ais_bind\x18\b \x01(\b:\x05falseR\x06isBind\x12\x15\n" +
	"\x02rw\x18\t \x01(\b:\x05falseR\x02rw\x12\x15\n" +
	"\x06is_dir\x18\n" +
	" \x01(\bR\x05isDir\x12\"\n" +
	"\tmandatory\x18\v \x01(\b:\x04trueR\tmandatory\x12$\n" +
	"\n" +
	"is_symlink\x18\f \x01(\b:\x05falseR\tisSymlink\x12\x1d\n" +
	"\x06nosuid\x18\r \x01(\b:\x05falseR\x06nosuid\x12\x1b\n" +
	"\x05nodev\x18\x0e \x01(\b:\x05falseR\x05nodev\x12\x1d\n" +
	"\x06noexec\x18\x0f \x01(\b:\x05falseR\x06noexec\"_\n" +
	"\x03Exe\x12\x12\n" +
	"\x04path\x18\x01 \x02(\tR\x04path\x12\x10\n" +
	"\x03arg\x18\x02 \x03(\tR\x03arg\x12\x12\n" +
	"\x04arg0\x18\x03 \x01(\tR\x04arg0\x12\x1e\n" +
	"\aexec_fd\x18\x04 \x01(\b:\x05falseR\x06execFd\"\xaf'\n" +
	"\fNsJailConfig\x12\x14\n" +
	"\x04name\x18\x01 \x01(\t:\x00R\x04name\x12 \n" +
	"\vdescription\x18\x02 \x03(\tR\vdescription\x12&\n" +
	"\x04mode\x18\x03 \x01(\x0e2\f.nsjail.Mode:\x04ONCER\x04mode\x12\"\n" +
	"\bhostname\x18\x04 \x01(\t:\x06NSJAILR\bhostname\x12\x13\n" +
	"\x03cwd\x18\x05 \x01(\t:\x01/R\x03cwd\x12(\n" +
	"\fno_pivotroot\x18\x06 \x01(\b:\x05falseR\vnoPivotroot\x12\x15\n" +
	"\x04port\x18\a \x01(\r:\x010R\x04port\x12\x1e\n" +
	"\bbindhost\x18\b \x01(\t:\x02::R\bbindhost\x12\x1e\n" +
	"\tmax_conns\x18\t \x01(\r:\x010R\bmaxConns\x12*\n" +
	"\x10max_conns_per_ip\x18\n" +
	" \x01(\r:\x010R\rmaxConnsPerIp\x12\"\n" +
	"\n" +
	"time_limit\x18\v \x01(\r:\x03600R\ttimeLimit\x12\x1d\n" +
	"\x06daemon\x18\f \x01(\b:\x05falseR\x06daemon\x12\x1c\n" +
	"\bmax_cpus\x18\r \x01(\r:\x010R\amaxCpus\x12!\n" +
	"\n" +
	"nice_level\x18\x0e \x01(\x05:\x0219R\tniceLevel\x12\x15\n" +
	"\x06log_fd\x18\x0f \x01(\x05R\x05logFd\x12\x19\n" +
	"\blog_file\x18\x10 \x01(\tR\alogFile\x12-\n" +
	"\tlog_level\x18\x11 \x01(\x0e2\x10.nsjail.LogLevelR\blogLevel\x12 \n" +
	"\bkeep_env\x18\x12 \x01(\b:\x05falseR\akeepEnv\x12\x14\n" +
	"\x05envar\x18\x13 \x03(\tR\x05envar\x12\"\n" +
	"\tkeep_caps\x18\x14 \x01(\b:\x05falseR\bkeepCaps\x12\x10\n" +
	"\x03cap\x18\x15 \x03(\tR\x03cap\x12\x1d\n" +
	"\x06silent\x18\x16 \x01(\b:\x05falseR\x06silent\x12&\n" +
	"\vskip_setsid\x18\x17 \x01(\b:\x05falseR\n" +
	"skipSetsid\x12+\n" +
	"\x0estderr_to_null\x18\x18 \x01(\b:\x05falseR\fstderrToNull\x12\x17\n" +
	"\apass_fd\x18\x19 \x03(\x05R\x06passFd\x126\n" +
	"\x14disable_no_new_privs\x18\x1a \x01(\b:\x05falseR\x11disableNoNewPrivs\x12.\n" +
	"\x0fforward_signals\x18\x1b \x01(\b:\x05falseR\x0eforwardSignals\x12&\n" +
	"\vdisable_tsc\x18\x1c \x01(\b:\x05falseR\n" +
	"disableTsc\x12!\n" +
	"\trlimit_as\x18\x1d \x01(\x04:\x044096R\brlimitAs\x12;\n" +
	"\x0erlimit_as_type\x18\x1e \x01(\x0e2\x0e.nsjail.RLimit:\x05VALUER\frlimitAsType\x12\"\n" +
	"\vrlimit_core\x18\x1f \x01(\x04:\x010R\n" +
	"rlimitCore\x12?\n" +
	"\x10rlimit_core_type\x18  \x01(\x0e2\x0e.nsjail.RLimit:\x05VALUER\x0erlimitCoreType\x12\"\n" +
	"\n" +
	"rlimit_cpu\x18! \x01(\x04:\x03600R\trlimitCpu\x12=\n" +
	"\x0frlimit_cpu_type\x18\" \x01(\x0e2\x0e.nsjail.RLimit:\x05VALUER\rrlimitCpuType\x12$\n" +
	"\frlimit_fsize\x18# \x01(\x04:\x011R\vrlimitFsize\x12A\n" +
	"\x11rlimit_fsize_type\x18$ \x01(\x0e2\x0e.nsjail.RLimit:\x05VALUER\x0frlimitFsizeType\x12'\n" +
	"\rrlimit_nofile\x18% \x01(\x04:\x0232R\frlimitNofile\x12C\n" +
	"\x12rlimit_nofile_type\x18& \x01(\x0e2\x0e.nsjail.RLimit:\x05VALUER\x10rlimitNofileType\x12'\n" +
	"\frlimit_nproc\x18' \x01(\x04:\x041024R\vrlimitNproc\x12@\n" +
	"\x11rlimit_nproc_type\x18( \x01(\x0e2\x0e.nsjail.RLimit:\x04SOFTR\x0frlimitNprocType\x12$\n" +
	"\frlimit_stack\x18) \x01(\x04:\x018R\vrlimitStack\x12@\n" +
	"\x11rlimit_stack_type\x18* \x01(\x0e2\x0e.nsjail.RLimit:\x04SOFTR\x0frlimitStackType\x12)\n" +
	"\x0erlimit_memlock\x18+ \x01(\x04:\x0264R\rrlimitMemlock\x12D\n" +
	"\x13rlimit_memlock_type\x18, \x01(\x0e2\x0e.nsjail.RLimit:\x04SOFTR\x11rlimitMemlockType\x12&\n" +
	"\rrlimit_rtprio\x18- \x01(\x04:\x010R\frlimitRtprio\x12B\n" +
	"\x12rlimit_rtprio_type\x18. \x01(\x0e2\x0e.nsjail.RLimit:\x04SOFTR\x10rlimitRtprioType\x12-\n" +
	"\x0frlimit_msgqueue\x18/ \x01(\x04:\x041024R\x0erlimitMsgqueue\x12F\n" +
	"\x14rlimit_msgqueue_type\x180 \x01(\x0e2\x0e.nsjail.RLimit:\x04SOFTR\x12rlimitMsgqueueType\x12$\n" +
	"\n" +
	"disable_rl\x181 \x01(\b:\x05falseR\tdisableRl\x12B\n" +
	"\x1apersona_addr_compat_layout\x182 \x01(\b:\x05falseR\x17personaAddrCompatLayout\x12:\n" +
	"\x16persona_mmap_page_zero\x183 \x01(\b:\x05falseR\x13personaMmapPageZero\x12@\n" +
	"\x19persona_read_implies_exec\x184 \x01(\b:\x05falseR\x16personaReadImpliesExec\x12:\n" +
	"\x16persona_addr_limit_3gb\x185 \x01(\b:\x05falseR\x13personaAddrLimit3gb\x12@\n" +
	"\x19persona_addr_no_randomize\x186 \x01(\b:\x05falseR\x16personaAddrNoRandomize\x12'\n" +
	"\fclone_newnet\x187 \x01(\b:\x04trueR\vcloneNewnet\x12)\n" +
	"\rclone_newuser\x188 \x01(\b:\x04trueR\fcloneNewuser\x12%\n" +
	"\vclone_newns\x189 \x01(\b:\x04trueR\n" +
	"cloneNewns\x12'\n" +
	"\fclone_newpid\x18: \x01(\b:\x04trueR\vcloneNewpid\x12'\n" +
	"\fclone_newipc\x18; \x01(\b:\x04trueR\vcloneNewipc\x12'\n" +
	"\fclone_newuts\x18< \x01(\b:\x04trueR\vcloneNewuts\x12-\n" +
	"\x0fclone_newcgroup\x18= \x01(\b:\x04trueR\x0ecloneNewcgroup\x12*\n" +
	"\rclone_newtime\x18> \x01(\b:\x05falseR\fcloneNewtime\x12%\n" +
	"\x06uidmap\x18? \x03(\v2\r.nsjail.IdMapR\x06uidmap\x12%\n" +
	"\x06gidmap\x18@ \x03(\v2\r.nsjail.IdMapR\x06gidmap\x12$\n" +
	"\n" +
	"mount_proc\x18A \x01(\b:\x05falseR\tmountProc\x12%\n" +
	"\x05mount\x18B \x03(\v2\x0f.nsjail.MountPtR\x05mount\x12.\n" +
	"\x13seccomp_policy_file\x18C \x01(\tR\x11seccompPolicyFile\x12%\n" +
	"\x0eseccomp_string\x18D \x03(\tR\rseccompString\x12&\n" +
	"\vseccomp_log\x18E \x01(\b:\x05falseR\n" +
	"seccompLog\x12'\n" +
	"\x0ecgroup_mem_max\x18F \x01(\x04:\x010R\fcgroupMemMax\x122\n" +
	"\x14cgroup_mem_memsw_max\x18G \x01(\x04:\x010R\x11cgroupMemMemswMax\x121\n" +
	"\x13cgroup_mem_swap_max\x18H \x01(\x03:\x02-1R\x10cgroupMemSwapMax\x12?\n" +
	"\x10cgroup_mem_mount\x18I \x01(\t:\x15/sys/fs/cgroup/memoryR\x0ecgroupMemMount\x122\n" +
	"\x11cgroup_mem_parent\x18J \x01(\t:\x06NSJAILR\x0fcgroupMemParent\x12)\n" +
	"\x0fcgroup_pids_max\x18K \x01(\x04:\x010R\rcgroupPidsMax\x12?\n" +
	"\x11cgroup_pids_mount\x18L \x01(\t:\x13/sys/fs/cgroup/pidsR\x0fcgroupPidsMount\x124\n" +
	"\x12cgroup_pids_parent\x18M \x01(\t:\x06NSJAILR\x10cgroupPidsParent\x126\n" +
	"\x16cgroup_net_cls_classid\x18N \x01(\r:\x010R\x13cgroupNetClsClassid\x12G\n" +
	"\x14cgroup_net_cls_mount\x18O \x01(\t:\x16/sys/fs/cgroup/net_clsR\x11cgroupNetClsMount\x129\n" +
	"\x15cgroup_net_cls_parent\x18P \x01(\t:\x06NSJAILR\x12cgroupNetClsParent\x123\n" +
	"\x15cgroup_cpu_ms_per_sec\x18Q \x01(\r:\x010R\x11cgroupCpuMsPerSec\x12<\n" +
	"\x10cgroup_cpu_mount\x18R \x01(\t:\x12/sys/fs/cgroup/cpuR\x0ecgroupCpuMount\x122\n" +
	"\x11cgroup_cpu_parent\x18S \x01(\t:\x06NSJAILR\x0fcgroupCpuParent\x125\n" +
	"\x0ecgroupv2_mount\x18T \x01(\t:\x0e/sys/fs/cgroupR\rcgroupv2Mount\x12(\n" +
	"\fuse_cgroupv2\x18U \x01(\b:\x05falseR\vuseCgroupv2\x12.\n" +
	"\x0fdetect_cgroupv2\x18V \x01(\b:\x05falseR\x0edetectCgroupv2\x12%\n" +
	"\viface_no_lo\x18W \x01(\b:\x05falseR\tifaceNoLo\x12\x1b\n" +
	"\tiface_own\x18X \x03(\tR\bifaceOwn\x12#\n" +
	"\rmacvlan_iface\x18Y \x01(\tR\fmacvlanIface\x12/\n" +
	"\rmacvlan_vs_ip\x18Z \x01(\t:\v192.168.0.2R\vmacvlanVsIp\x121\n" +
	"\rmacvlan_vs_nm\x18[ \x01(\t:\r255.255.255.0R\vmacvlanVsNm\x12/\n" +
	"\rmacvlan_vs_gw\x18\\ \x01(\t:\v192.168.0.1R\vmacvlanVsGw\x12$\n" +
	"\rmacvlan_vs_ma\x18] \x01(\t:\x00R\vmacvlanVsMa\x12+\n" +
	"\rmacvlan_vs_mo\x18^ \x01(\t:\aprivateR\vmacvlanVsMo\x127\n" +
	"\buser_net\x18_ \x01(\v2\x1c.nsjail.NsJailConfig.UserNetR\auserNet\x12&\n" +
	"\bexec_bin\x18` \x01(\v2\v.nsjail.ExeR\aexecBin\x1a\xa4\x05\n" +
	"\aUserNet\x12\x1d\n" +
	"\x06enable\x18\x01 \x01(\b:\x05falseR\x06enable\x12\x1c\n" +
	"\x02ip\x18\x02 \x01(\t:\f10.255.255.2R\x02ip\x12!\n" +
	"\x04mask\x18\x03 \x01(\t:\r255.255.255.0R\x04mask\x12\x1c\n" +
	"\x02gw\x18\x04 \x01(\t:\f10.255.255.1R\x02gw\x12\x19\n" +
	"\x03ip6\x18\x05 \x01(\t:\afc00::2R\x03ip6\x12\x18\n" +
	"\x05mask6\x18\x06 \x01(\t:\x0264R\x05mask6\x12\x19\n" +
	"\x03gw6\x18\a \x01(\t:\afc00::1R\x03gw6\x12\x1f\n" +
	"\bns_iface\x18\b \x01(\t:\x04eth0R\ansIface\x12!\n" +
	"\ttcp_ports\x18\t \x01(\t:\x04noneR\btcpPorts\x12!\n" +
	"\tudp_ports\x18\n" +
	" \x01(\t:\x04noneR\budpPorts\x12-\n" +
	"\x0fenable_ip4_dhcp\x18\v \x01(\b:\x05falseR\renableIp4Dhcp\x12$\n" +
	"\n" +
	"enable_dns\x18\f \x01(\b:\x05falseR\tenableDns\x12!\n" +
	"\vdns_forward\x18\r \x01(\t:\x00R\n" +
	"dnsForward\x12#\n" +
	"\n" +
	"enable_tcp\x18\x0e \x01(\b:\x04trueR\tenableTcp\x12#\n" +
	"\n" +
	"enable_udp\x18\x0f \x01(\b:\x04trueR\tenableUdp\x12%\n" +
	"\venable_icmp\x18\x10 \x01(\b:\x04trueR\n" +
	"enableIcmp\x12!\n" +
	"\tno_map_gw\x18\x11 \x01(\b:\x05falseR\anoMapGw\x12-\n" +
	"\x0fenable_ip6_dhcp\x18\x12 \x01(\b:\x05falseR\renableIp6Dhcp\x12)\n" +
	"\renable_ip6_ra\x18\x13 \x01(\b:\x05falseR\venableIp6Ra*3\n" +
	"\x04Mode\x12\n" +
	"\n" +
	"\x06LISTEN\x10\x00\x12\b\n" +
	"\x04ONCE\x10\x01\x12\t\n" +
	"\x05RERUN\x10\x02\x12\n" +
	"\n" +
	"\x06EXECVE\x10\x03*B\n" +
	"\bLogLevel\x12\t\n" +
	"\x05DEBUG\x10\x00\x12\b\n" +
	"\x04INFO\x10\x01\x12\v\n" +
	"\aWARNING\x10\x02\x12\t\n" +
	"\x05ERROR\x10\x03\x12\t\n" +
	"\x05FATAL\x10\x04*0\n" +
	"\x06RLimit\x12\t\n" +
	"\x05VALUE\x10\x00\x12\b\n" +
	"\x04SOFT\x10\x01\x12\b\n" +
	"\x04HARD\x10\x02\x12\a\n" +
	"\x03INF\x10\x03"

var (
	file_config_proto_rawDescOnce sync.Once
	file_config_proto_rawDescData []byte
)

func file_config_proto_rawDescGZIP() []byte {
	file_config_proto_rawDescOnce.Do(func() {
		file_config_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_config_proto_rawDesc), len(file_config_proto_rawDesc)))
	})
	return file_config_proto_rawDescData
}

var file_config_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_config_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_config_proto_goTypes = []any{
	(Mode)(0),                    // 0: nsjail.Mode
	(LogLevel)(0),                // 1: nsjail.LogLevel
	(RLimit)(0),                  // 2: nsjail.RLimit
	(*IdMap)(nil),                // 3: nsjail.IdMap
	(*MountPt)(nil),              // 4: nsjail.MountPt
	(*Exe)(nil),                  // 5: nsjail.Exe
	(*NsJailConfig)(nil),         // 6: nsjail.NsJailConfig
	(*NsJailConfig_UserNet)(nil), // 7: nsjail.NsJailConfig.UserNet
}
var file_config_proto_depIdxs = []int32{
	0,  // 0: nsjail.NsJailConfig.mode:type_name -> nsjail.Mode
	1,  // 1: nsjail.NsJailConfig.log_level:type_name -> nsjail.LogLevel
	2,  // 2: nsjail.NsJailConfig.rlimit_as_type:type_name -> nsjail.RLimit
	2,  // 3: nsjail.NsJailConfig.rlimit_core_type:type_name -> nsjail.RLimit
	2,  // 4: nsjail.NsJailConfig.rlimit_cpu_type:type_name -> nsjail.RLimit
	2,  // 5: nsjail.NsJailConfig.rlimit_fsize_type:type_name -> nsjail.RLimit
	2,  // 6: nsjail.NsJailConfig.rlimit_nofile_type:type_name -> nsjail.RLimit
	2,  // 7: nsjail.NsJailConfig.rlimit_nproc_type:type_name -> nsjail.RLimit
	2,  // 8: nsjail.NsJailConfig.rlimit_stack_type:type_name -> nsjail.RLimit
	2,  // 9: nsjail.NsJailConfig.rlimit_memlock_type:type_name -> nsjail.RLimit
	2,  // 10: nsjail.NsJailConfig.rlimit_rtprio_type:type_name -> nsjail.RLimit
	2,  // 11: nsjail.NsJailConfig.rlimit_msgqueue_type:type_name -> nsjail.RLimit
	3,  // 12: nsjail.NsJailConfig.uidmap:type_name -> nsjail.IdMap
	3,  // 13: nsjail.NsJailConfig.gidmap:type_name -> nsjail.IdMap
	4,  // 14: nsjail.NsJailConfig.mount:type_name -> nsjail.MountPt
	7,  // 15: nsjail.NsJailConfig.user_net:type_name -> nsjail.NsJailConfig.UserNet
	5,  // 16: nsjail.NsJailConfig.exec_bin:type_name -> nsjail.Exe
	17, // [17:17] is the sub-list for method output_type
	17, // [17:17] is the sub-list for method input_type
	17, // [17:17] is the sub-list for extension type_name
	17, // [17:17] is the sub-list for extension extendee
	0,  // [0:17] is the sub-list for field type_name
}

func init() { file_config_proto_init() }
func file_config_proto_init() {
	if File_config_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_config_proto_rawDesc), len(file_config_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_config_proto_goTypes,
		DependencyIndexes: file_config_proto_depIdxs,
		EnumInfos:         file_config_proto_enumTypes,
		MessageInfos:      file_config_proto_msgTypes,
	}.Build()
	File_config_proto = out.File
	file_config_proto_goTypes = nil
	file_config_proto_depIdxs = nil
}
